diff --git a/arch/arm64/boot/dts/qcom/batterydata-J6B-nvt-5020mah.dtsi b/arch/arm64/boot/dts/qcom/batterydata-J6B-nvt-5020mah.dtsi
index e61f98c..f7293ce 100644
--- a/arch/arm64/boot/dts/qcom/batterydata-J6B-nvt-5020mah.dtsi
+++ b/arch/arm64/boot/dts/qcom/batterydata-J6B-nvt-5020mah.dtsi
@@ -22,11 +22,11 @@ qcom,j6b-nvt-5020mah {
 	qcom,qg-batt-profile-ver = <100>;
 	mi,six-pin-battery;
 
-	qcom,jeita-fcc-ranges = <0  50   950000
-				51  100  2400000
-				101 150  3400000
+	qcom,jeita-fcc-ranges = <0  50   1000000
+				51  100  2500000
+				101 150  4100000
 				151 450  6000000
-				451 580  2400000>;
+				451 580  2500000>;
 
 	qcom,jeita-fv-ranges = <0   50   4450000
 				51  100  4450000
@@ -34,6 +34,15 @@ qcom,j6b-nvt-5020mah {
 				151 450  4450000
 				451 580  4100000>;
 
+	/* COOL = 10 degc, WARM = 45 degC */
+	qcom,jeita-soft-thresholds = <0x4ccc 0x20b8>;
+	/* COLD = 0 degC, HOT = 55 degC*/
+	qcom,jeita-hard-thresholds = <0x58cd 0x181d>;
+	/* COOL hys = 13 degC, WARM hys = 42 degC */
+	qcom,jeita-soft-hys-thresholds = <0x48d4 0x23c0>;
+	qcom,jeita-soft-fcc-ua = <1000000 2500000>;
+	qcom,jeita-soft-fv-uv = <4450000 4100000>;
+
 	qcom,fcc1-temp-lut {
 		qcom,lut-col-legend = <0 10 25 40 50>;
 		qcom,lut-data = <3191 3260 3320 3354 3366>;
diff --git a/arch/arm64/boot/dts/qcom/batterydata-J6B-sunwoda-5020mah.dtsi b/arch/arm64/boot/dts/qcom/batterydata-J6B-sunwoda-5020mah.dtsi
index 2a9f015..87bf5b5 100644
--- a/arch/arm64/boot/dts/qcom/batterydata-J6B-sunwoda-5020mah.dtsi
+++ b/arch/arm64/boot/dts/qcom/batterydata-J6B-sunwoda-5020mah.dtsi
@@ -22,11 +22,11 @@ qcom,j6b-sunwoda-5020mah {
 	qcom,qg-batt-profile-ver = <100>;
 	mi,six-pin-battery;
 
-	qcom,jeita-fcc-ranges = <0  50   950000
-				51  100  2400000
-				101 150  3400000
+	qcom,jeita-fcc-ranges = <0  50   1000000
+				51  100  2500000
+				101 150  4100000
 				151 450  6000000
-				451 580  2400000>;
+				451 580  2500000>;
 
 	qcom,jeita-fv-ranges = <0   50   4450000
 				51  100  4450000
@@ -34,6 +34,15 @@ qcom,j6b-sunwoda-5020mah {
 				151 450  4450000
 				451 580  4100000>;
 
+	/* COOL = 10 degc, WARM = 45 degC */
+	qcom,jeita-soft-thresholds = <0x4ccc 0x20b8>;
+	/* COLD = 0 degC, HOT = 55 degC*/
+	qcom,jeita-hard-thresholds = <0x58cd 0x181d>;
+	/* COOL hys = 13 degC, WARM hys = 42 degC */
+	qcom,jeita-soft-hys-thresholds = <0x48d4 0x23c0>;
+	qcom,jeita-soft-fcc-ua = <1000000 2500000>;
+	qcom,jeita-soft-fv-uv = <4450000 4100000>;
+
 	qcom,fcc1-temp-lut {
 		qcom,lut-col-legend = <0 10 25 40 50>;
 		qcom,lut-data = <3191 3260 3320 3354 3366>;
diff --git a/arch/arm64/boot/dts/qcom/sdmmagpie-idp.dtsi b/arch/arm64/boot/dts/qcom/sdmmagpie-idp.dtsi
index 10c4dcf..98e37f3 100644
--- a/arch/arm64/boot/dts/qcom/sdmmagpie-idp.dtsi
+++ b/arch/arm64/boot/dts/qcom/sdmmagpie-idp.dtsi
@@ -406,7 +406,7 @@
 	qcom,fcc-stepping-enable;
 	qcom,suspend-input-on-debug-batt;
 	qcom,sec-charger-config = <3>;
-	qcom,thermal-mitigation = <3000000 2500000 2000000 1500000 1000000 500000>;
+	qcom,thermal-mitigation = <3600000 3300000 3000000 2500000 2000000 1500000 1000000 500000>;
 	dpdm-supply = <&qusb_phy0>;
 	qcom,charger-temp-max = <800>;
 	qcom,smb-temp-max = <800>;
diff --git a/drivers/power/supply/qcom/qpnp-smb5.c b/drivers/power/supply/qcom/qpnp-smb5.c
index 08f2da6..a980751 100644
--- a/drivers/power/supply/qcom/qpnp-smb5.c
+++ b/drivers/power/supply/qcom/qpnp-smb5.c
@@ -30,6 +30,22 @@
 #include "smb5-lib.h"
 #include "schgm-flash.h"
 
+#include <linux/notifier.h>
+#include <linux/msm_drm_notify.h>
+#include <linux/fb.h>
+union power_supply_propval lct_therm_lvl_reserved;
+union power_supply_propval lct_therm_level;
+
+union power_supply_propval lct_therm_call_level = {6,};
+
+
+union power_supply_propval lct_therm_globe_level = {3,};
+union power_supply_propval lct_therm_india_level = {1,};
+
+
+bool lct_backlight_off;
+int LctIsInCall = 0;
+int LctThermal =0;
 static struct smb_params smb5_pmi632_params = {
 	.fcc			= {
 		.name   = "fast charge current",
@@ -1598,6 +1614,7 @@ static enum power_supply_property smb5_batt_props[] = {
 	POWER_SUPPLY_PROP_FORCE_RECHARGE,
 	POWER_SUPPLY_PROP_FCC_STEPPER_ENABLE,
 	POWER_SUPPLY_PROP_CHARGING_ENABLED,
+	POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL,
 };
 
 #define DEBUG_ACCESSORY_TEMP_DECIDEGC	250
@@ -1738,6 +1755,9 @@ static int smb5_batt_get_prop(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_FCC_STEPPER_ENABLE:
 		val->intval = chg->fcc_stepper_enable;
 		break;
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		rc = smblib_get_prop_system_temp_level(chg, val);
+		break;
 	default:
 		pr_err("batt power supply prop %d not supported\n", psp);
 		return -EINVAL;
@@ -1839,6 +1859,9 @@ static int smb5_batt_set_prop(struct power_supply *psy,
 			vote(chg->chg_disable_votable, FORCE_RECHARGE_VOTER,
 					false, 0);
 		break;
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		rc = smblib_set_prop_system_temp_level(chg, val);
+		break;
 	case POWER_SUPPLY_PROP_FCC_STEPPER_ENABLE:
 		chg->fcc_stepper_enable = val->intval;
 		break;
@@ -3466,6 +3489,99 @@ static void smb5_create_debugfs(struct smb5 *chip)
 
 #endif
 
+static ssize_t lct_thermal_call_status_show(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", LctIsInCall);
+}
+static ssize_t lct_thermal_call_status_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned long input;
+
+	retval = kstrtol(buf, 10, &input);
+	if (retval < 0){
+		pr_err("kstrtol fail%d\n", retval);
+		return retval;
+	}
+
+    LctIsInCall = input;
+	pr_info("IsInCall = %d\n", LctIsInCall);
+
+	return count;
+}
+
+static struct device_attribute attrs2[] = {
+	__ATTR(thermalcall, S_IRUGO | S_IWUSR,
+			lct_thermal_call_status_show, lct_thermal_call_status_store),
+};
+
+static void thermal_fb_notifier_resume_work(struct work_struct *work)
+{
+	struct smb_charger *chg = container_of(work, struct smb_charger, fb_notify_work);
+	LctThermal = 1;
+
+		if ((lct_backlight_off) && (LctIsInCall == 0) )
+		{
+			if (lct_therm_lvl_reserved.intval >= 2)
+				smblib_set_prop_system_temp_level(chg,&lct_therm_globe_level);//level 2 2.2A
+		else
+			smblib_set_prop_system_temp_level(chg,&lct_therm_lvl_reserved);//from thermal-level
+		}
+		else if (LctIsInCall == 1)
+			smblib_set_prop_system_temp_level(chg,&lct_therm_call_level);//level 5 800ma
+		else
+			smblib_set_prop_system_temp_level(chg,&lct_therm_lvl_reserved);//from thermal-levle
+		LctThermal = 0;
+}
+
+/* frame buffer notifier block control the suspend/resume procedure */
+static int thermal_notifier_callback(struct notifier_block *noti, unsigned long event, void *data)
+{
+	struct fb_event *ev_data = data;
+	struct smb_charger *chg = container_of(noti, struct smb_charger, notifier);
+	int *blank;
+	printk("%s %d",__FUNCTION__,__LINE__);
+	if (ev_data && ev_data->data && chg) {
+		blank = ev_data->data;
+		if (event == MSM_DRM_EARLY_EVENT_BLANK && *blank == MSM_DRM_BLANK_UNBLANK) {
+			lct_backlight_off = false;
+			pr_info("thermal_notifier lct_backlight_off:%d",lct_backlight_off);
+			schedule_work(&chg->fb_notify_work);
+		}
+		else if (event == MSM_DRM_EVENT_BLANK && *blank == MSM_DRM_BLANK_POWERDOWN) {
+			lct_backlight_off = true;
+			pr_info("thermal_notifier lct_backlight_off:%d",lct_backlight_off);
+			schedule_work(&chg->fb_notify_work);
+		}
+	}
+
+	return 0;
+}
+
+static int lct_register_powermanger(struct smb_charger *chg)
+{
+	int ret = 0;
+
+	chg->notifier.notifier_call = thermal_notifier_callback;
+	ret = msm_drm_register_client(&chg->notifier);
+    if (ret)
+        pr_err("[FB]Unable to register fb_notifier: %d", ret);
+
+	return 0;
+}
+
+static int lct_unregister_powermanger(struct smb_charger *chg)
+{
+
+	msm_drm_unregister_client(&chg->notifier);
+
+	return 0;
+}
+
+
+
 static int smb5_show_charger_status(struct smb5 *chip)
 {
 	struct smb_charger *chg = &chip->chg;
@@ -3519,6 +3635,7 @@ static int smb5_probe(struct platform_device *pdev)
 	struct smb5 *chip;
 	struct smb_charger *chg;
 	int rc = 0;
+	unsigned char attr_count2;
 
 	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);
 	if (!chip)
@@ -3669,7 +3786,16 @@ static int smb5_probe(struct platform_device *pdev)
 		pr_err("Couldn't initialize batt psy rc=%d\n", rc);
 		goto cleanup;
 	}
-
+	pr_info("enter sysfs create file thermal\n");
+	for (attr_count2 = 0; attr_count2 < ARRAY_SIZE(attrs2); attr_count2++) {
+		    rc = sysfs_create_file(&chg->dev->kobj,
+						&attrs2[attr_count2].attr);
+			if (rc < 0) {
+				pr_info(" sysfs create file fail %d\n",rc);
+		        sysfs_remove_file(&chg->dev->kobj,
+						&attrs2[attr_count2].attr);
+			}
+		}
 	/* Register android dual-role class */
 	rc = smb5_init_dual_role_class(chip);
 	if (rc < 0) {
@@ -3707,6 +3833,13 @@ static int smb5_probe(struct platform_device *pdev)
 
 	device_init_wakeup(chg->dev, true);
 
+	lct_therm_lvl_reserved.intval= 0;
+	lct_therm_level.intval= 0;
+	lct_backlight_off = false;
+	INIT_WORK(&chg->fb_notify_work, thermal_fb_notifier_resume_work);
+	/* register suspend and resume fucntion*/
+	lct_register_powermanger(chg);
+
 	pr_info("QPNP SMB5 probed successfully\n");
 
 	return rc;
@@ -3724,6 +3857,13 @@ static int smb5_remove(struct platform_device *pdev)
 {
 	struct smb5 *chip = platform_get_drvdata(pdev);
 	struct smb_charger *chg = &chip->chg;
+	unsigned char attr_count2;
+
+	for (attr_count2 = 0; attr_count2 < ARRAY_SIZE(attrs2); attr_count2++) {
+			  sysfs_remove_file(&chg->dev->kobj,
+							&attrs2[attr_count2].attr);
+			}
+	lct_unregister_powermanger(chg);
 
 	/* force enable APSD */
 	smblib_masked_write(chg, USBIN_OPTIONS_1_CFG_REG,
diff --git a/drivers/power/supply/qcom/smb5-lib.c b/drivers/power/supply/qcom/smb5-lib.c
index 2ba8941..3b5b42a 100644
--- a/drivers/power/supply/qcom/smb5-lib.c
+++ b/drivers/power/supply/qcom/smb5-lib.c
@@ -2369,6 +2369,11 @@ int smblib_set_prop_battery_charging_enabled(struct smb_charger *chg,
 
   return 0;
 }
+extern union power_supply_propval lct_therm_lvl_reserved;
+extern bool lct_backlight_off;
+extern int LctIsInCall;
+extern int LctThermal;
+
 int smblib_set_prop_system_temp_level(struct smb_charger *chg,
 				const union power_supply_propval *val)
 {
@@ -2381,7 +2386,31 @@ int smblib_set_prop_system_temp_level(struct smb_charger *chg,
 	if (val->intval > chg->thermal_levels)
 		return -EINVAL;
 
+	pr_info("%s val=%d, chg->system_temp_level=%d, LctThermal=%d, lct_backlight_off= %d, IsInCall=%d \n " 
+		,__FUNCTION__,val->intval,chg->system_temp_level, LctThermal, lct_backlight_off, LctIsInCall);
+
+	if (LctThermal == 0) { //from therml-engine always store lvl_sel
+		lct_therm_lvl_reserved.intval = val->intval;
+	}
+
+	/*backlight off and not-incall, force minimum level 3*/
+	if ((lct_backlight_off) && (LctIsInCall == 0) && (val->intval > 3)) {
+		pr_info("leve ignored:backlight_off:%d level:%d",lct_backlight_off,val->intval);
+		return 0;
+	}
+
+	/*incall,force level 5*/
+	if ((LctIsInCall == 1) && (val->intval != 6)) {
+		pr_info("leve ignored:LctIsInCall:%d level:%d",LctIsInCall,val->intval);
+		return 0;
+	}
+
+	if (val->intval == chg->system_temp_level)
+		return 0;
+
 	chg->system_temp_level = val->intval;
+	pr_info("%s intval:%d system temp level:%d thermal_levels:%d",
+		__FUNCTION__,val->intval,chg->system_temp_level,chg->thermal_levels);
 
 	if (chg->system_temp_level == chg->thermal_levels)
 		return vote(chg->chg_disable_votable,
diff --git a/drivers/power/supply/qcom/smb5-lib.h b/drivers/power/supply/qcom/smb5-lib.h
index 9aa57a7..7fe20ad 100644
--- a/drivers/power/supply/qcom/smb5-lib.h
+++ b/drivers/power/supply/qcom/smb5-lib.h
@@ -622,6 +622,9 @@ int			pd_verifed;
 	int			dcin_uv_count;
 	ktime_t			dcin_uv_last_time;
 	int			last_wls_vout;
+	struct notifier_block notifier;
+	struct work_struct fb_notify_work;
+
 };
 
 int smblib_read(struct smb_charger *chg, u16 addr, u8 *val);
